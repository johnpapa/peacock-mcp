import { McpServer, ResourceTemplate } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";

// Generated by Copilot
const PEACOCK_REPO = process.env.PEACOCK_REPO || "https://github.com/johnpapa/vscode-peacock";
const PEACOCK_API_URL = PEACOCK_REPO.replace("github.com", "api.github.com/repos");
const PEACOCK_RAW_CONTENT = PEACOCK_REPO.replace("github.com", "raw.githubusercontent.com") + "/main";

// Generated by Copilot
// Cache for documentation content
let docsCache: Record<string, string> = {};
let docFilesList: string[] = [];
let isDocsCacheInitialized = false;

const server = new McpServer(
  {
    name: "peacock-mcp",
    version: "1.0.0",
    description: "An MCP Server to retrieve Peacock usage information from the docs.",
  },
  {
    capabilities: {
      tools: {},
    },
  }
);

// Add an addition tool
server.tool(
  "quackadoodle",
  "Adds two numbers together + 7 more for fun.",
  { a: z.number(), b: z.number() },
  async ({ a, b }) => ({
    content: [{ type: "text", text: String(a + b + 7) }],
  })
);

// Async tool with external API call
server.tool(
  "fetch-star-wars",
  "Fetches the Star Wars information from an API, by person id",
  { people_id: z.string() },
  async ({ people_id }) => {
    const response = await fetch(`https://swapi.dev/api/people/${people_id}`);
    const data = await response.text();
    return {
      content: [{ type: "text", text: data }],
    };
  }
);

// Generated by Copilot
// Helper function to fetch files list from a GitHub repository directory
async function fetchDirectoryContents(path: string): Promise<Array<{ name: string; type: string; path: string }>> {
  try {
    const url = `${PEACOCK_API_URL}/contents/${path}`;
    const response = await fetch(url);

    if (!response.ok) {
      console.error(`Failed to fetch directory contents: ${response.status} - ${response.statusText}`);
      return [];
    }

    const data = (await response.json()) as Array<{ name: string; type: string; path: string }>;
    return data;
  } catch (error) {
    console.error(`Error fetching directory contents: ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

// Generated by Copilot
// Helper function to initialize docs cache by fetching all markdown files in the docs directory
async function initializeDocsCache(): Promise<boolean> {
  try {
    // Fetch README.md from root
    const readmeResponse = await fetch(`${PEACOCK_RAW_CONTENT}/README.md`);
    if (readmeResponse.ok) {
      const readmeContent = await readmeResponse.text();
      docsCache["README.md"] = readmeContent;
      docFilesList.push("README.md");
    }

    // Fetch contents of the docs directory
    const docsContents = await fetchDirectoryContents("docs");

    // Process each item in the directory
    for (const item of docsContents) {
      // Skip folders that begin with a dot (.)
      if (item.name.startsWith(".")) {
        continue;
      }

      if (item.type === "file" && item.name.endsWith(".md")) {
        // If it's a markdown file, fetch its contents
        const fileResponse = await fetch(`${PEACOCK_RAW_CONTENT}/${item.path}`);
        if (fileResponse.ok) {
          const content = await fileResponse.text();
          docsCache[item.path] = content;
          docFilesList.push(item.path);
        }
      } else if (item.type === "dir") {
        // If it's a directory, fetch its contents recursively
        const subDirContents = await fetchDirectoryContents(item.path);
        for (const subItem of subDirContents) {
          // Skip nested items in folders that begin with a dot (.)
          if (subItem.name.startsWith(".")) {
            continue;
          }

          if (subItem.type === "file" && subItem.name.endsWith(".md")) {
            const fileResponse = await fetch(`${PEACOCK_RAW_CONTENT}/${subItem.path}`);
            if (fileResponse.ok) {
              const content = await fileResponse.text();
              docsCache[subItem.path] = content;
              docFilesList.push(subItem.path);
            }
          }
        }
      }
    }

    console.error(`Indexed ${docFilesList.length} documentation files from Peacock repository`);
    return true;
  } catch (error) {
    console.error(`Error initializing docs cache: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// Generated by Copilot
// Helper function to search through documentation content
function searchDocumentation(query: string): { results: string; sources: string[] } {
  const queryLower = query.toLowerCase();
  const relevantContent: string[] = [];
  const sources: string[] = [];

  // Search through all documentation files
  for (const [filePath, content] of Object.entries(docsCache)) {
    if (content.toLowerCase().includes(queryLower)) {
      // Extract the relevant section (paragraph or section) containing the query
      const lines = content.split("\n");
      let inRelevantSection = false;
      let sectionContent = "";

      for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        const lineLower = line.toLowerCase();

        // Check if this line contains the query
        if (lineLower.includes(queryLower)) {
          inRelevantSection = true;

          // Include the heading before this line if it exists
          let j = i - 1;
          while (j >= 0 && j >= i - 5) {
            if (lines[j].startsWith("#")) {
              sectionContent = lines[j] + "\n\n" + sectionContent;
              break;
            }
            j--;
          }
        }

        // If we're in a relevant section, add the line
        if (inRelevantSection) {
          sectionContent += line + "\n";
        }

        // Check if we should end the section
        if (inRelevantSection && (line.trim() === "" || i === lines.length - 1 || line.startsWith("#"))) {
          if (sectionContent.trim()) {
            relevantContent.push(sectionContent.trim());
            sources.push(filePath);
          }
          inRelevantSection = false;
          sectionContent = "";
        }
      }
    }
  }

  // Combine the relevant content
  return {
    results: relevantContent.join("\n\n---\n\n"),
    sources: [...new Set(sources)], // Deduplicate sources
  };
}

// Generated by Copilot
// Tool to fetch Peacock documentation and answer questions
server.tool(
  "fetch-peacock-docs",
  "Fetches the Peacock for VS Code extension docs from its GitHub repository and answers questions based on the documentation",
  { query: z.string().describe("The question to answer based on the Peacock documentation") },
  async ({ query }) => {
    try {
      // Initialize the docs cache if not already done
      if (!isDocsCacheInitialized) {
        const initialized = await initializeDocsCache();
        if (!initialized) {
          return {
            content: [
              {
                type: "text",
                text: "Failed to initialize documentation cache. Please try again later.",
              },
            ],
          };
        }
        isDocsCacheInitialized = true;
      }

      // If the cache is empty (initialization failed or no docs found)
      if (Object.keys(docsCache).length === 0) {
        return {
          content: [
            {
              type: "text",
              text: "No documentation files were found in the Peacock repository.",
            },
          ],
        };
      }

      // If the query is a request for available documentation files
      if (query.toLowerCase().includes("available") && query.toLowerCase().includes("files")) {
        return {
          content: [
            {
              type: "text",
              text: `Available documentation files:\n${docFilesList.join("\n")}`,
            },
          ],
        };
      }

      // Search the documentation for relevant content
      const { results, sources } = searchDocumentation(query);

      if (!results) {
        return {
          content: [
            {
              type: "text",
              text: `No information related to "${query}" was found in the Peacock documentation.`,
            },
          ],
        };
      }

      return {
        content: [
          {
            type: "text",
            text: `Information related to "${query}":\n\n${results}\n\nSources: ${sources.join(", ")}`,
          },
        ],
      };
    } catch (error) {
      return {
        content: [
          {
            type: "text",
            text: `Error searching Peacock documentation: ${error instanceof Error ? error.message : String(error)}`,
          },
        ],
      };
    }
  }
);

async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
  console.error("Peacock MCP Server running on stdio");
}

main().catch((err) => {
  console.error("Fatal error:", err);
  process.exit(1);
});
