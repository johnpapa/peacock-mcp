// Generated by Copilot

// Repository URLs and constants
export const PEACOCK_REPO = process.env.PEACOCK_REPO || "https://github.com/johnpapa/vscode-peacock";
export const PEACOCK_API_URL = PEACOCK_REPO.replace("github.com", "api.github.com/repos");
export const PEACOCK_RAW_CONTENT = PEACOCK_REPO.replace("github.com", "raw.githubusercontent.com") + "/main";

// Documentation cache state
export let docsCache: Record<string, string> = {};
export let docFilesList: string[] = [];
export let isDocsCacheInitialized = false;

// Fetch repository directory contents
export async function fetchDirectoryContents(
  path: string
): Promise<Array<{ name: string; type: string; path: string }>> {
  try {
    const url = `${PEACOCK_API_URL}/contents/${path}`;
    const response = await fetch(url);
    if (!response.ok) return [];
    return await response.json();
  } catch (error) {
    console.error(`Error fetching directory: ${error instanceof Error ? error.message : String(error)}`);
    return [];
  }
}

// Fetch markdown file content
export async function fetchMarkdownFile(path: string): Promise<string | null> {
  try {
    const response = await fetch(`${PEACOCK_RAW_CONTENT}/${path}`);
    return response.ok ? await response.text() : null;
  } catch {
    return null;
  }
}

// Process a markdown file - add to cache if valid
export async function processMarkdownFile(filePath: string): Promise<boolean> {
  const content = await fetchMarkdownFile(filePath);
  if (!content) return false;

  docsCache[filePath] = content;
  docFilesList.push(filePath);
  return true;
}

// Process directory items recursively
export async function processDirectoryItems(items: Array<{ name: string; type: string; path: string }>): Promise<void> {
  for (const item of items) {
    if (item.name.startsWith(".")) continue;

    if (item.type === "file" && item.name.endsWith(".md")) {
      await processMarkdownFile(item.path);
    } else if (item.type === "dir") {
      const subItems = await fetchDirectoryContents(item.path);
      await processDirectoryItems(subItems);
    }
  }
}

// Initialize documentation cache
export async function initializeDocsCache(): Promise<boolean> {
  try {
    await processMarkdownFile("README.md");
    const docsItems = await fetchDirectoryContents("docs");
    await processDirectoryItems(docsItems);

    console.error(`Indexed ${docFilesList.length} documentation files from Peacock repository`);
    return docFilesList.length > 0;
  } catch (error) {
    console.error(`Error initializing docs cache: ${error instanceof Error ? error.message : String(error)}`);
    return false;
  }
}

// Extract heading before a matched line
export function findPrecedingHeading(lines: string[], currentIndex: number): string {
  for (let j = currentIndex - 1; j >= 0 && j >= currentIndex - 5; j--) {
    if (lines[j].startsWith("#")) return lines[j];
  }
  return "";
}

// Process a section of content that matches the query
export function processMatchingSection(
  lines: string[],
  startIndex: number,
  query: string
): {
  content: string;
  endIndex: number;
} {
  let sectionContent = "";
  const heading = findPrecedingHeading(lines, startIndex);
  if (heading) sectionContent = heading + "\n\n";

  let i = startIndex;
  while (i < lines.length) {
    sectionContent += lines[i] + "\n";
    i++;
    if (i === lines.length || lines[i].trim() === "" || lines[i].startsWith("#")) break;
  }

  return { content: sectionContent.trim(), endIndex: i };
}

// Search documentation for a query
export function searchDocumentation(query: string): { results: string; sources: string[] } {
  const queryLower = query.toLowerCase();
  const relevantContent: string[] = [];
  const sources: string[] = [];

  for (const [filePath, content] of Object.entries(docsCache)) {
    if (!content.toLowerCase().includes(queryLower)) continue;

    const lines = content.split("\n");
    for (let i = 0; i < lines.length; i++) {
      if (lines[i].toLowerCase().includes(queryLower)) {
        const { content: sectionContent, endIndex } = processMatchingSection(lines, i, queryLower);
        if (sectionContent) {
          relevantContent.push(sectionContent);
          sources.push(filePath);
        }
        i = endIndex;
      }
    }
  }

  return {
    results: relevantContent.join("\n\n---\n\n"),
    sources: [...new Set(sources)],
  };
}

// Create response for documentation query
export async function handleDocumentationQuery(query: string): Promise<{ text: string }> {
  // Initialize cache if needed
  if (!isDocsCacheInitialized) {
    isDocsCacheInitialized = await initializeDocsCache();
    if (!isDocsCacheInitialized) {
      return { text: "Failed to initialize documentation cache. Please try again later." };
    }
  }

  // Check if cache is empty
  if (Object.keys(docsCache).length === 0) {
    return { text: "No documentation files were found in the Peacock repository." };
  }

  // Handle listing available files
  if (query.toLowerCase().includes("available") && query.toLowerCase().includes("files")) {
    return { text: `Available documentation files:\n${docFilesList.join("\n")}` };
  }

  // Search documentation
  const { results, sources } = searchDocumentation(query);
  if (!results) {
    return { text: `No information related to "${query}" was found in the Peacock documentation.` };
  }

  return { text: `Information related to "${query}":\n\n${results}\n\nSources: ${sources.join(", ")}` };
}
